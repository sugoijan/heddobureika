set dotenv-load
set shell := ["zsh", "-cu"]

ADMIN_TOKEN := env_var_or_default("ADMIN_TOKEN", env_var_or_default("ROOM_ADMIN_TOKEN", ""))
#ROOM_WS_BASE_URL := env_var_or_default("ROOM_WS_BASE_URL", "ws://127.0.0.1:8787/ws")
WRANGLER_LOG_PATH := env_var_or_default("WRANGLER_LOG_PATH", ".wrangler/logs")
WRANGLER_PORT := env_var_or_default("WRANGLER_PORT", "8787")
TRUNK_PORT := env_var_or_default("TRUNK_PORT", "8081")
CADDY_PUBLIC_PORT := env_var_or_default("CADDY_PUBLIC_PORT", "8080")
CADDY_CONFIG := env_var_or_default("CADDY_CONFIG", "Caddyfile.dev")

# Show available tasks
default:
    @just --list

# Create a local .dev.vars file for wrangler dev
dev-vars:
    @cp -n .dev.vars.example .dev.vars
    @echo "Created .dev.vars if it didn't exist. Update ADMIN_TOKEN inside it."

# Run the worker locally (no Cloudflare login required)
wrangler-dev:
    @WRANGLER_LOG_PATH="{{WRANGLER_LOG_PATH}}" pnpm exec wrangler dev --local --host 127.0.0.1 --port {{WRANGLER_PORT}} --persist-to .wrangler/state --show-interactive-dev-session=false

# Run the frontend locally (requires trunk)
trunk-serve:
    @mkdir -p .wrangler target node_modules
    @trunk serve --port {{TRUNK_PORT}}

# Run Caddy dev proxy (serves on CADDY_PUBLIC_PORT)
caddy-run:
    @CADDY_PUBLIC_PORT="{{CADDY_PUBLIC_PORT}}" TRUNK_PORT="{{TRUNK_PORT}}" WRANGLER_PORT="{{WRANGLER_PORT}}" caddy run --config {{CADDY_CONFIG}}

# Run worker + frontend + proxy together
[parallel]
dev: wrangler-dev trunk-serve caddy-run

# Update Rust lockfile to latest versions allowed by manifests
update-cargo:
    @cargo update -v

# Update pnpm lockfile to latest versions allowed by manifests
update-pnpm:
    @pnpm update -r

# Update both Rust and pnpm
update: update-cargo update-pnpm

# Clean local artifacts generated by dev workflows
clean: clean-trunk clean-wrangler clean-cargo clean-worker-build clean-node

# Clean frontend build output/cache
clean-trunk:
    @rm -rf dist .trunk

# Clean wrangler local state/logs
clean-wrangler:
    @rm -rf .wrangler

# Clean cargo build output
clean-cargo:
    @rm -rf target

# Clean worker build artifacts
clean-worker-build:
    @rm -rf worker/build

# Clean node install artifacts
clean-node:
    @rm -rf node_modules

# Build the worker (requires worker-build)
worker-build:
    @cd worker && worker-build --release

# One-time setup for local worker build tool
setup-worker-build:
    @cargo install -q worker-build

# Cargo-check the worker (wasm target)
worker-check:
    @cargo check -p heddobureika-worker --target wasm32-unknown-unknown

# Cargo-check the admin CLI (native target)
cli-check:
    @cargo check -p heddobureika-cli

# Check the web app
app-check:
    @cargo check -p heddobureika --target wasm32-unknown-unknown

# Check the core create
code-check:
    @cargo check -p heddobureika-core --target wasm32-unknown-unknown

# Check the image-pipeline crate
image-pipeline-check:
    @cargo check -p heddobureika-image-pipeline --target wasm32-unknown-unknown

# Run all checks (worker uses wasm target, CLI uses native)
check: worker-check cli-check app-check

# Run wasm-bindgen tests in the browser via cargo runner
wasm-test browser="firefox":
    @case "{{browser}}" in \
      firefox) GECKODRIVER=geckodriver cargo test -p heddobureika --target wasm32-unknown-unknown ;; \
      chrome) CHROMEDRIVER=chromedriver cargo test -p heddobureika --target wasm32-unknown-unknown ;; \
      safari) SAFARIDRIVER=safaridriver cargo test -p heddobureika --target wasm32-unknown-unknown ;; \
      *) echo "unknown browser '{{browser}}' (use firefox|chrome|safari)"; exit 2 ;; \
    esac

# Run a single wasm smoke test to verify the runner works
wasm-test-smoke browser="firefox":
    @case "{{browser}}" in \
      firefox) GECKODRIVER=geckodriver cargo test -p heddobureika --target wasm32-unknown-unknown wasm_smoke ;; \
      chrome) CHROMEDRIVER=chromedriver cargo test -p heddobureika --target wasm32-unknown-unknown wasm_smoke ;; \
      safari) SAFARIDRIVER=safaridriver cargo test -p heddobureika --target wasm32-unknown-unknown wasm_smoke ;; \
      *) echo "unknown browser '{{browser}}' (use firefox|chrome|safari)"; exit 2 ;; \
    esac

# Run shader unit tests (no yew)
test-shaders:
    @cargo test -p heddobureika --no-default-features --test shader_validation

# Run shader browser tests (WebGL2/WebGPU, no yew)
test-shaders-browser browser="firefox":
    @case "{{browser}}" in \
      firefox) GECKODRIVER=geckodriver cargo test -p heddobureika --target wasm32-unknown-unknown --no-default-features --test shader_browser ;; \
      chrome) CHROMEDRIVER=chromedriver cargo test -p heddobureika --target wasm32-unknown-unknown --no-default-features --test shader_browser ;; \
      safari) SAFARIDRIVER=safaridriver cargo test -p heddobureika --target wasm32-unknown-unknown --no-default-features --test shader_browser ;; \
      *) echo "unknown browser '{{browser}}' (use firefox|chrome|safari)"; exit 2 ;; \
    esac

# Run only the multiplayer wasm test with output enabled
wasm-test-mp browser="firefox":
    @case "{{browser}}" in \
      firefox) GECKODRIVER=geckodriver cargo test -p heddobureika --target wasm32-unknown-unknown multiplayer_warns_when_image_missing -- --nocapture ;; \
      chrome) CHROMEDRIVER=chromedriver cargo test -p heddobureika --target wasm32-unknown-unknown multiplayer_warns_when_image_missing -- --nocapture ;; \
      safari) SAFARIDRIVER=safaridriver cargo test -p heddobureika --target wasm32-unknown-unknown multiplayer_warns_when_image_missing -- --nocapture ;; \
      *) echo "unknown browser '{{browser}}' (use firefox|chrome|safari)"; exit 2 ;; \
    esac

# Integration test: requires worker running and ADMIN_TOKEN/ROOM_ADMIN_TOKEN set
mp-test:
    @cargo test -p heddobureika-cli --test multiplayer_sync

# Process-level integration test for CLI private upload flow
integration-test-cli:
    @pnpm test:integration:cli

# Create/activate a room via the admin CLI
create-room *args:
    @if [ -f .dev.vars ]; then \
      set -a; source .dev.vars; set +a; \
    fi; \
    token="${ADMIN_TOKEN:-${ROOM_ADMIN_TOKEN:-}}"; \
    if [ -z "$token" ]; then \
      echo "Missing admin token. Set ADMIN_TOKEN (or ROOM_ADMIN_TOKEN) or use .dev.vars."; \
      exit 1; \
    fi; \
    base_url="${ROOM_WS_BASE_URL:-ws://127.0.0.1:{{WRANGLER_PORT}}/ws}"; \
    set -- {{args}}; \
    if printf ' %s ' "$@" | grep -q -- ' --base-url '; then \
      cargo run -p heddobureika-cli -- rooms create --admin-token "$token" "$@"; \
    else \
      cargo run -p heddobureika-cli -- rooms create --admin-token "$token" --base-url "$base_url" "$@"; \
    fi

# Run a single heuristic bot client against an existing room
bot-run room_id *args:
    @base_url="${ROOM_WS_BASE_URL:-ws://127.0.0.1:{{WRANGLER_PORT}}/ws}"; \
    cargo run -p heddobureika-cli -- rooms bot run --room-id "{{room_id}}" --base-url "$base_url" "$@"

# Show per-room durable recording status
recording-status room_id *args:
    @if [ -f .dev.vars ]; then \
      set -a; source .dev.vars; set +a; \
    fi; \
    token="${ADMIN_TOKEN:-${ROOM_ADMIN_TOKEN:-}}"; \
    if [ -z "$token" ]; then \
      echo "Missing admin token. Set ADMIN_TOKEN (or ROOM_ADMIN_TOKEN) or use .dev.vars."; \
      exit 1; \
    fi; \
    base_url="${ROOM_WS_BASE_URL:-ws://127.0.0.1:{{WRANGLER_PORT}}/ws}"; \
    cargo run -p heddobureika-cli -- rooms recording status --room-id "{{room_id}}" --admin-token "$token" --base-url "$base_url" "$@"

deploy:
    @if [ -f .env.local ]; then \
      set -a; source .env.local; set +a; \
    fi; \
    if [ -z "${DEPLOY_PUBLIC_URL:-}" ] || [ -z "${DEPLOY_RSYNC_DEST:-}" ]; then \
      echo "Missing DEPLOY_PUBLIC_URL or DEPLOY_RSYNC_DEST. Set them in .env.local."; \
      exit 1; \
    fi; \
    trunk build --release --public-url "$DEPLOY_PUBLIC_URL"; \
    rsync --progress -av --delete dist/ "$DEPLOY_RSYNC_DEST"
